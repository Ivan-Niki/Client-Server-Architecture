
------------- Существует несколько способов работы API, например:
- SOAP API
- REST API
- Websocket API
- RPC API

1) REST - это архитектурный стиль взаимодействия компонентов приложения в сети, также это особый тип Web API. 
Архитектурный стиль - это набор ограничений и принципов проектирования свойств системы, которые необходимы для лучшего масштабирования и интеграции с другими сервисами.

2) SOAP - это протокол, по которому взаимодействуют веб-сервисы между друг другом или с клиентом.

3) Websocket API - это одна из разработок web API, которая позволяет открыть постоянное двунаправленное сетевое соединение между клиентом и сервером. 
Использует JSON для передачи данных.

Пример типов сообщений:
Subscribe (подписка на топик)
Unsubscribe (отписка на топик)
Message (получение сообщений)
Oauth.logheartbit (контроль статуса соединения)

4) RPC API - система удаленного вызова процедур. Клиент совершает функцию на сервере, и сервер отправляет обратно результат.



---------------- Что такое веб-сервисы? ---------------

Веб-сервисы (или веб-службы) — это технология, позволяющая системам обмениваться данными друг с другом через сетевое подключение. 
Обычно веб-сервисы работают поверх протокола HTTP или протокола более высокого уровня. 
Веб-сервис — просто адрес, ссылка, обращение к которому позволяет получить данные или выполнить действие.

Главное отличие веб-сервиса от других способов передачи данных: стандартизированность. 
Приняв решение использовать веб-сервисы, можно сразу переходить к структуре данных и доступным функциям. Например, в SOAP (как более строгом протоколе), уже решён вопрос уведомления об ошибках.

Самые известные способы реализации веб-сервисов:
--> XML-RPC (XML Remote Procedure Call) — протокол удаленного вызова процедур с использованием XML. Прародитель SOAP. Предельно прост в реализации.

--> SOAP (Simple Object Access Protocol) — стандартный протокол по версии W3C. Четко структурирован и задокументирован.

--> JSON-RPC (JSON Remote Procedure Call) — более современный аналог XML-RPC. Основное отличие — данные передаются в формате JSON.

--> REST (Representational State Transfer) — архитектурный стиль взаимодействия компьютерных систем в сети основанный на методах протокола HTTP.

--> Специализированные протоколы для конкретного вида задач, такие как GraphQL.

--> Менее распространенный, но более эффективный gRPC, передающий данные в бинарном виде и использующий HTTP/2 в качестве транспорта.

Остальные протоколы не так широко распространены.



---------------- SOAP ----------------

SOAP (Simple Object Access Protocol) — данные передаются в формате XML.
Преимущества:
- отраслевой стандарт по версии W3C;
- наличие строгой спецификации;
- широкая поддержка в продуктах Microsoft,
- однозначность.

Недостатки:
- сложность реализации;
- сложность/ресурсоемкость парсинга XML-данных.

Любое сообщение в протоколе SOAP — это XML документ, состоящий из следующих элементов (тегов):
--> Envelope. Корневой обязательный элемент. Определяет начало и окончание сообщения.
--> Header. Необязательный элемент — заголовок. Содержит элементы, необходимые для обработки самого сообщения. Например, идентификатор сессии.
--> Body. Основной элемент, содержит основную информацию сообщения. Обязательный.
--> Fault. Элемент, содержащий информацию об ошибках, возникающих в процессе обработки сообщения. Необязательный.



----- Пример SOAP-запроса на сервер интернет-магазина:

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
   <soap:Body>
     <getProductDetails xmlns="http://warehouse.example.com/ws">
       <productID>12345</productID>
     </getProductDetails>
   </soap:Body>
</soap:Envelope>

----- Пример ответа:

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
   <soap:Body>
     <getProductDetailsResponse xmlns="http://warehouse.example.com/ws">
       <getProductDetailsResult>
         <productID>12345</productID>
         <productName>Стакан граненый</productName>
         <description>Стакан граненый. 250 мл.</description>
         <price>9.95</price>
         <currency>
             <code>840</code>
             <alpha3>USD</alpha3>
             <sign>$</sign>
             <name>US dollar</name>
             <accuracy>2</accuracy>
         </currency>
         <inStock>true</inStock>
       </getProductDetailsResult>
     </getProductDetailsResponse>
   </soap:Body>
</soap:Envelope>



---------------- REST ----------------
REST (Representational State Transfer) — на самом деле архитектурный стиль, а не протокол. 
В отличие от SOAP, REST не подкреплен официальным стандартом. Фактически, он основывается на соглашениях. 
Веб-сервис, построенный с учетом всех требований и ограничений архитектурного стиля, можно назвать RESTful веб-сервисом.
REST не использует конвертацию данных при передаче, данные передаются в исходном виде — это снижает нагрузку на клиент веб-сервиса, но увеличивает нагрузку на сеть. 
Управление данными происходит с помощью методов HTTP:
- GET — получить данные;
- POST — добавить данные;
- PUT — изменить данные;
- DELETE — удалить данные.

Использование этих методов позволяет реализовать типичный CRUD (Create/Read/Update/Delete) для любой информации. Но это лишь соглашение: часто используются только 2 метода: GET для получения и POST для всего остального. Разобраться поможет такое понятие, как REST-Patterns. Паттерны связывают HTTP методы с тем, что они делают.



---------------- RPC ----------------
У семейства протоколов RPC (Remote Procedure Call) свой отличительный подход — удаленный вызов процедур.
В отличие от REST, одна точка входа, и телом запроса определяется, какой ресурс или какое действие будет выполнено. Реализаций подхода не так много. 
Главным образом они различаются форматом передачи данных — XML, JSON или бинарный.

---> XML-RPC и SOAP
XML-RPC изначально был разработан Microsoft в конце 90-х годов. Это текстовый протокол, в изначальном виде довольно прост в освоении. 
Единственная проблема этого формата — это сам XML (eXtensible Markup Language). 
XML, как формат передачи данных, довольно избыточен. В первую очередь, из-за открывающих и закрывающих тегов. 
У HTML в каком-то смысле та же проблема, но ничего другого для верстки не существует.

Позже Microsoft разработали еще один протокол, который стал расширением XML-RPC — SOAP (Simple Object Access Protocol). 
У него более строгая структура, много ограничений и требований. Сам протокол может работать поверх множества сетевых протоколов – SMTP, FTP и т.д. 
Сейчас SOAP используется для общений между сервисами (в основном с 1С) и для отправки SMS. 
Некоторые сервисы вроде интернет-магазинов до сих пор используют его для внутренних нужд — для SOAP один раз описывается схема передачи данных, 
дальше большинство SOAP-клиентов сами могут сформировать запрос и ответ без дополнительных действий со стороны разработчика.


---> JSON-RPC
JSON-RPC — это протокол семейства RPC, у которого в качестве формата передачи данных используется JSON.
Несмотря на простоту и внешнее удобство, не получил популярности. В том числе из-за REST API с поддержкой JSON в качестве формата передачи данных. 
Но не так давно в React сообществе появился новый формат общения между разными частями приложения, построенного на фреймворке Next.js – tRPC. 
Является версией JSON-RPC с поддержкой типизации из TypeScript. 
Протокол относительно молодой, основное применение и развитие происходит пока только внутри React (Next.js) сообщества. 
Но внимания заслуживает. В остальном же JSON-RPC популярность не снискал и практически не используется.


---> gRPC
gRPC — это бинарный протокол, т.е. данные передаются в бинарном виде, а не в виде текста. 
Разработан в Google и изначально использовался только для унификации взаимодействий между сервисов внутри самой компании. 
В 2016 году был выпущен в публичный доступ. 

Для кодирования и декодирования сообщений используется собственный протокол сериализации Protobuf (Protocol Buffers).
Максимально похожий на структуры из языка Си. Из плюсов Protobuf выделяют компактность, скорость сериализации и десериализации (особенно в сравнении с XML-форматами). 
Для описания формата сообщений и обработчиков пишутся *.proto файлы. 
Потом эти файлы компилируются в язык, на котором пишется приложение — Java, Python, PHP, JavaScript, Go и многие другие. 
Стоит отметить, что в Go-среде получил наибольшее распространение.

Главным ограничением протокола является то, что он работает поверх HTTP/2. 
Это полностью (на данный момент) исключает его использование в браузерах. 
Поэтому gRPC — протокол исключительно для общения сервисов на стороне бэкенда. 
Протокол очень популярен. Поэтому, если вы не столкнетесь с ним в первый год работы, иметь о нем представление будет полезно.



--------------------- WebSocket ----------------------
WebSocket — это протокол двусторонней связи для постоянного обмена сообщениями клиента и сервера. 
Как и HTTP, WebSocket работает поверх TCP. Но вместо периодического соединения формата «запрос – ответ», держит постоянное соединение с сервером. 
Поэтому сервер всегда знает конкретного клиента «в лицо» и может отправить ему данные без дополнительного запроса. 
Например, используется для систем оповещений и чатов браузерных игр.
В отличие от gRPC, вам не нужно будет изучать какой-то специфический формат обмена данными. 
WebSocket использует свой собственный бинарный формат, внутри которого вы можете передавать что угодно в удобной для вашего приложения форме.

Общение через WebSocket может быть реализовано по принципам REST — HTTP-метод + ресурс + тело запроса. 
Или реализовано, как JSON-RPC — имя процедуры + список параметров. 
Либо вовсе использовать GraphQL — называется «подпиской» (subscription).

Самое частое применение WebSocket — real-time чаты. Новое сообщение получатель видит, когда сервер рассылает сообщения всем адресатам, а не когда запрашивает сам. 
Библиотеки для WebSocket-сервера существуют почти для всех языков и их фреймворков. 
Вопрос будет только в выборе самого популярного и/или удобного лично для вас.


---------- Подробнее про веб-сокеты ----------
Итак, нам нужен способ для моментальной отправки информации на сервер и такого же быстрого получения обновлений с сервера. 
Это возвращает нас к двусторонней («дуплексной») связи, с которой хорошо справляются именно веб-сокеты.

Поддерживаемый почти всеми современными браузерами API WebSocket позволяет открывать именно такое двустороннее соединение с сервером. 
Кроме того, сервер может отслеживать каждого клиента и отправлять сообщения подмножеству клиентов. 
То есть с помощью веб-сокетов мы можем пригласить всех друзей в наш чат и отправлять сообщения всем или некоторым из них, 
а не только одному человеку, как при использовании других протоколов связи.

В тексте мы уже несколько раз упоминали HTTP — протокол и набор правил взаимодействия компьютеров в сети. 
Он состоит из запросов и ответов, каждый из которых содержит строку запроса («GET /assets/icon.png»), 
заголовки и необязательное тело сообщения, используемое, например, в POST-запросах для отправки некоторых данных на сервер.
WebSocket — это еще один протокол для отправки и получения сообщений. 
Как и HTTP, веб-сокеты отправляют сообщения через соединение TCP (протокол управления передачей данных). 
Это стандарт, который обеспечивает надежную и предсказуемую доставку данных, отправляемых в пакетах.

Итак, HTTP и WebSocket используют один и тот же механизм доставки на уровне пакетов, но протоколы структурирования сообщений у них различаются:

Чтобы установить соединение веб-сокетов с сервером, клиент сначала отправляет HTTP-запрос «рукопожатия» с заголовком нашего обновления, указывая, что клиент хочет установить соединение WebSocket.
Запрос отправляется на ws: или wss:: URI (аналог http или https).
Если сервер устанавливает соединение WebSocket, и это соединение разрешено, например, если запрос исходит от клиента, прошедшего проверку подлинности или внесенного в белый список, то сервер отправляет ответ об успешном рукопожатии. На это указывает HTTP-код 101 Switching Protocols.
После обновления соединения протокол переключается с HTTP на WebSocket. И хотя все пакеты по-прежнему отправляются через TCP, связь теперь соответствует формату сообщений WebSocket. 
Это происходит, потому что TCP является дуплексным протоколом, где клиент и сервер могут отправлять сообщения одновременно. 
Все данные могут быть фрагментированы, поэтому через этот формат можно отправить даже очень большое сообщение — например, изображение. 
В этом случае веб-сокеты разбивают его на фреймы. Каждый фрейм содержит небольшой заголовок, который указывает длину и тип полезной нагрузки, а также информацию, является ли этот кадр последним.

Сервер может открывать соединения WebSocket с несколькими клиентами — даже несколько соединений с одним и тем же клиентом. 
Затем он может отправить сообщение одному, нескольким или всем этим клиентам. На практике это означает, что к нашему чату могут подключиться несколько человек, и мы можем отправлять сообщения некоторым из них одновременно.

Наконец, когда соединение можно закрыть, либо клиент, либо сервер могут отправить сообщение «закрыть».

